### 大O
- O(1),O(n),O(nlogn),O(nlogn),O(n^2)
- 大O描述的是算法的运行时间和输入数据之间的关系

O(n)是nums中的元素个数算法和n呈线性关系，忽略了常数。实际是
```
T = c1*n + c2;
但是
T = 2*n + 2 O(n)
T = 2000*n + 10000 O(n)
T = 1*n*n + 0 O(n^2)

上面的表达式中第三个n下于3000的时候都是比前面的要小的，但是在n接近无穷的时候，
就是不一样了，所以O是渐进时间复杂度描述n趋近于无穷的情况

```

- O一般是计算最坏的结果
- 均摊复杂度，有时早规律出现的时候可以使用均摊复杂度
- 复杂度震荡，在边界情况下，来回操作，过于着急（Eager)解决方案就是Lazy

![Big O graphs](https://zky.koocdn.com/club/picture/8d5d86ecb45043edb99825cebccd5632.png)

源: [Big O Cheat Sheet](http://bigocheatsheet.com/).

以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。

| 大O标记法      | 计算10个元素                 | 计算100个元素                 | 计算1000个元素                  |
| -------------- | ---------------------------- | ----------------------------- | ------------------------------- |
| **O(1)**       | 1                            | 1                             | 1                               |
| **O(log N)**   | 3                            | 6                             | 9                               |
| **O(N)**       | 10                           | 100                           | 1000                            |
| **O(N log N)** | 30                           | 600                           | 9000                            |
| **O(N^2)**     | 100                          | 10000                         | 1000000                         |
| **O(2^N)**     | 1024                         | 1.26e+29                      | 1.07e+301                       |
| **O(N!)**      | 3628800                      | 9.3e+157                      | 4.02e+2567                      |

### 数据结构操作的复杂性

| 数据结构                | 连接      | 查找      | 插入      | 删除      |
| ----------------------- | :-------: | :-------: | :-------: | :-------: |
| **数组**                | 1         | n         | n         | n         |
| **栈**                  | n         | n         | 1         | 1         |
| **队列**                | n         | n         | 1         | 1         |
| **链表**                | n         | n         | 1         | 1         |
| **哈希表**              | -         | n         | n         | n         |
| **二分查找树**          | n         | n         | n         | n         |
| **B树**                 | log(n)    | log(n)    | log(n)    | log(n)    |
| **红黑树**              | log(n)    | log(n)    | log(n)    | log(n)    |
| **AVL树**               | log(n)    | log(n)    | log(n)    | log(n)    |

### 数组排序算法的复杂性

| 名称                  | 最优      | 平均      | 最坏          | 内存      | 稳定      |
| --------------------- | :-------: | :-------: | :-----------: | :-------: | :-------: |
| **冒泡排序**          | n         | n^2       | n^2           | 1         | Yes       |
| **插入排序**          | n         | n^2       | n^2           | 1         | Yes       |
| **选择排序**          | n^2       | n^2       | n^2           | 1         | No        |
| **堆排序**            | n log(n)  | n log(n)  | n log(n)      | 1         | No        |
| **归并排序**          | n log(n)  | n log(n)  | n log(n)      | n         | Yes       |
| **快速排序**          | n log(n)  | n log(n)  | n^2           | log(n)    | No        |
| **希尔排序**          | n log(n)  | 取决于差距序列   | n (log(n))^2  | 1         | No        |
